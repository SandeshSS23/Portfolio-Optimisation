# -*- coding: utf-8 -*-
"""my-genetic-algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sBZCc8JSCptp3QFSBUFU0uLf-mrSCqtZ
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import yfinance as yf
import requests
import time
import matplotlib.pyplot as plt
import random

def generate_portfolios(num_portfolios,stocks):
  portfolios = []


  for _ in range(num_portfolios):
    portfolio = [random.random() for _ in range(len(stocks))]
    total_size = sum(portfolio)
    portfolio = [w/total_size for w in portfolio]
    portfolios.append(portfolio)
  return portfolios



def calculate_sharpe_ratio(portfolio,correlation_matrix, expected_returns_mean,stocks, riskfree):
  portfolio_weights = np.array(portfolio)
#   portfolio_variance = np.dot(portfolio_weights, np.dot(correlation_matrix, portfolio_weights))
  portfolio_variance = 0


  for i in range(len(stocks)):
    covariance_weight = 0
    for j in range(len(stocks)):
       covariance_weight += correlation_matrix[stocks[i]][stocks[j]]*portfolio_weights[j]

    portfolio_variance += portfolio_weights[i]*covariance_weight


  returns = 0
  for i in range(len(stocks)):
    returns += portfolio[i]*(expected_returns_mean[stocks[i]])

#   adjusted_returns = returns - riskfree
  adjusted_returns = returns

  return returns/portfolio_variance


def calculate_stock_score(ticker_symbol):
    balance_sheet = []
    income_statement = []
    cfs = []
    years = []
    profitability_score = 0
    leverage_score = 0
    operating_efficiency_score = 0
    total_score = 9

    # Get data
    ticker = yf.Ticker(ticker_symbol)
    balance_sheet = ticker.balance_sheet
    income_statement = ticker.income_stmt
    cfs = ticker.cashflow
    years = balance_sheet.columns

    # Profitability calculation
    try:

        net_income = income_statement[years[0]]['Net Income']
        net_income_py = income_statement[years[1]]['Net Income']
        ni_score = 1 if net_income > 0 else 0
        ni_score_2 = 1 if net_income > net_income_py else 0


        op_cf = cfs[years[0]]['Net Income From Continuing Operations']
        op_cf_score = 1 if op_cf > 0 else 0
        avg_assets = (balance_sheet[years[0]]['Total Assets'] + balance_sheet[years[1]]['Total Assets']) / 2
        avg_assets_py = (balance_sheet[years[1]]['Total Assets'] + balance_sheet[years[2]]['Total Assets']) / 2
        RoA = net_income / avg_assets
        RoA_py = net_income_py / avg_assets_py
        RoA_score = 1 if RoA > RoA_py else 0
        total_assets = balance_sheet[years[0]]['Total Assets']

        accruals = op_cf / total_assets - RoA
        ac_score = 1 if accruals > 0 else 0
        profitability_score = ni_score + ni_score_2 + op_cf_score + RoA_score + ac_score
    except KeyError:
        # print(f"Could not calculate profitability for {ticker_symbol}")
        profitability_score = 0
        total_score -= 5

    # Leverage calculation
    try:
        lt_debt = balance_sheet[years[0]]['Long Term Debt']
        total_assets = balance_sheet[years[0]]['Total Assets']
        debt_ratio = lt_debt / total_assets
        debt_ratio_score = 1 if debt_ratio < 0.4 else 0
    except KeyError:
        # print(f"Could not calculate leverage for {ticker_symbol}")
        debt_ratio_score = 0
        total_score -= 1

    # debt assets ratio
    try:
        current_assets = balance_sheet[years[0]]['Current Liabilities']
        current_liab = balance_sheet[years[0]]['Current Assets']
        current_ratio = current_assets / current_liab
        current_ratio_score = 1 if current_ratio > 1 else 0
    except KeyError:
        # print(f"Could not calculate current ratio for {ticker_symbol}")
        current_ratio_score = 0
        total_score -= 1


    leverage_score = debt_ratio_score + current_ratio_score

    # Operating Efficiency calculation
    try:
        gp = income_statement[years[0]]['Gross Profit']
        gp_py = income_statement[years[1]]['Gross Profit']

        revenue = income_statement[years[0]]['Total Revenue']
        revenue_py = income_statement[years[1]]['Total Revenue']

        gm = gp / revenue
        gm_py = gp_py / revenue_py
        gm_score = 1 if gm > gm_py else 0

        avg_assets = (balance_sheet[years[0]]['Total Assets'] + balance_sheet[years[1]]['Total Assets']) / 2
        avg_assets_py = (balance_sheet[years[1]]['Total Assets'] + balance_sheet[years[2]]['Total Assets']) / 2
        at = revenue / avg_assets  # at = asset turnover
        at_py = revenue_py / avg_assets_py
        at_score = 1 if at > at_py else 0
        operating_efficiency_score = gm_score + at_score
        
    except KeyError:
        # print(f"Could not calculate operating efficiency for {ticker_symbol}")
        operating_efficiency_score = 0
        total_score -= 2

    # Summary update
    summary = pd.DataFrame(columns=['Ticker', 'Profitability', 'Leverage', 'Operating eficiency'])
    new_row = {'Ticker': ticker_symbol,
               'Profitability': profitability_score,
               'Leverage': leverage_score,
               'Operating eficiency': operating_efficiency_score}
    summary = summary._append(new_row, ignore_index=True)

    summary['Total score'] = summary['Profitability'] + summary['Leverage'] + summary['Operating eficiency']

    # print(ticker_symbol, ' added.')
    time.sleep(3)

    if total_score == 0:
        return 0.3
    else:
        return summary['Total score'].values[0]/total_score


def calculate_fitness_function(portfolio,correlation_matrix, expected_returns_mean,stocks, riskfree,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight):
    sharpe = calculate_sharpe_ratio(portfolio,correlation_matrix, expected_returns_mean,stocks, riskfree)

    #Herfindahl-Hirschman Index (HHI) 
    hhi = sum(weight**2 for weight in portfolio)
    diversification_score = 1 - hhi
    stock_score_cumulative = 0
    for i in range (len(stocks)):
        stock_score_cumulative += (stock_scores[i]*portfolio[i])

    fitness_score = (fundamental_weight*stock_score_cumulative) + (sharpe_weight*sharpe) + (diversification_weight*diversification_score)

    return fitness_score

def select_fittest_population(portfolios, correlation_matrix, expected_returns_mean, stocks,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight):
    riskfree = 0.012
    # fitness_scores = [calculate_sharpe_ratio(portfolio, correlation_matrix, expected_returns_mean, stocks,riskfree) for portfolio in portfolios]
    fitness_scores = [calculate_fitness_function(portfolio,correlation_matrix, expected_returns_mean,stocks, riskfree,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight) for portfolio in portfolios]
    return [x for _, x in sorted(zip(fitness_scores, portfolios), reverse=True)]

def crossover(portfolio1, portfolio2):
    crossover_point = random.randint(0, len(portfolio1))
    child = portfolio1[:crossover_point] + portfolio2[crossover_point:]
    total_size = sum(child)
    child = [w / total_size for w in child]
    return child

def mutate(portfolio, mutation_rate):
    for i in range(len(portfolio)):
        if random.random() < mutation_rate:
            portfolio[i] = random.random()
    total_size = sum(portfolio)
    portfolio = [w / total_size for w in portfolio]
    return portfolio

def genetic_algorithm(stocks, correlation_matrix, expected_returns_mean, num_portfolios, generations, mutation_rate,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight):
    riskfree = 0.012
    population = generate_portfolios(num_portfolios,stocks)
    fittest_population = select_fittest_population(population, correlation_matrix, expected_returns_mean, stocks,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight)
    elite_size = int(0.2 * num_portfolios)  # 20% of fittest population to be preserved

    for generation in range(generations):
        mating_pool = fittest_population[:elite_size]
        for _ in range(num_portfolios - elite_size):
            parent1 = random.choice(fittest_population)
            parent2 = random.choice(fittest_population)
            offspring = crossover(parent1, parent2)
            offspring = mutate(offspring, mutation_rate)
            mating_pool.append(offspring)

        fittest_population = select_fittest_population(mating_pool, correlation_matrix, expected_returns_mean, stocks,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight)
        print(f"Generation {generation + 1}, Best Fitness: {calculate_fitness_function(fittest_population[0], correlation_matrix, expected_returns_mean, stocks, riskfree,stock_scores,sharpe_weight , fundamental_weight ,diversification_weight)}")

    return fittest_population[0]



def generate_pie_chart(portfolio, title,stocks):
    labels = stocks
    fig, ax = plt.subplots(figsize=(10, 5))
    ax.pie(portfolio, labels=labels, autopct='%1.1f%%')
    ax.set_title(title)

    # Return the Matplotlib figure
    return fig


